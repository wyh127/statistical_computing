prime <- rep(Inf, n)
x_init <- x0
h <- 0.001
step <- 0.001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
prime <- prime / abs(max(prime))
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.00001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.0001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 500, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.0001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.0001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
prime <- prime / abs(max(prime))
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.0001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
ind_max <- which(abs(prime) == max(abs(prime)))
x_init <- x_init - step * units[ind_max, ]
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * units[ind_max, ]
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.00001
step <- 0.0001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.000000001
step <- 0.001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
# calculate gradeint
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.000000001
step <- 0.00001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
# calculate gradeint
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.0000000001
step <- 0.00001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
# calculate gradeint
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
logistic.nlm$estimate
logistic.nlm$iterations
logistic.nlm$minimum
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.001
step <- 1e-15
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
# calculate gradeint
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.001
step <- 0.00001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
# calculate gradeint
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.001
step <- 0.00001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
# calculate gradeint
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=c(-10.276279060, 0.05522738, 0.08686777, 0.001614479, 0.106627782, -0.071821442, -1.154123414, 0.123325485))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.001
step <- 0.00001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
# calculate gradeint
for(i in c(1:n)) {
if(abs(prime[i]) > stopping.deriv) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=c(-10, 0.055, 0.086, 0.0016, 0.11, -0.072, -1.15, 0.123))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.001
step <- 0.00001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
# calculate gradeint
for(i in c(1:n)) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=c(-10, 0.055, 0.086, 0.0016, 0.11, -0.072, -1.15, 0.123))
Newtons.Method(logistic.NLL, x0=rep(0, 8))
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
h <- 0.001
step <- 0.00001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
# calculate gradeint
for(i in c(1:n)) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
print(prime)
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), prime_res = prime, iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0, 8))
logistic.nlm <- nlm(logistic.NLL, p=rep(0,8), data=prostate)
logistic.nlm$estimate
logistic.nlm$iterations
logistic.nlm$minimum
logistic.nlm <- nlm(logistic.NLL, p=rep(0,8), data=prostate)
logistic.nlm$estimate
logistic.nlm$iterations
Newtons.Method <- function(f, x0, max.iter = 200, stopping.deriv = 0.001, ...) {
n <- length(x0)
iter <- 0
prime <- rep(Inf, n)
x_init <- x0
# for calculating derivate
h <- 0.001
# for updating x_init
step <- 0.00001
# create a set of unit vectors for calculating gradeint vectors
units <- diag(n)
while(iter < max.iter & (sum(abs(prime) > stopping.deriv) > 0)) {
# calculate gradient elementwisely
for(i in c(1:n)) {
prime[i] <- (f(x_init + h * units[i, ]) - f(x_init)) / h
}
x_init <- x_init - step * prime
iter <- iter+1
}
res <- list(x_res = x_init, f_res = f(x_init), prime_res = prime, iter_res = iter, conv = (iter < max.iter))
return(res)
}
Newtons.Method(logistic.NLL, x0=rep(0,8))
